<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Struycken Algorithm Image Processor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        h4 {
            margin: 0.6em 0;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }
        .canvas-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            flex-wrap: wrap;
        }
        canvas {
            background-color: white;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 100%;
            height: auto;
            max-width: 450px;
            aspect-ratio: 1 / 1;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px 30px;
        }
        @media (max-width: 700px) {
            .controls {
                grid-template-columns: 1fr;
            }
            .canvas-container {
                flex-direction: column;
                align-items: center;
            }
            .canvas-container > div {
                width: 100%;
            }
        }
        @media (min-width: 701px) and (max-width: 1000px) {
            canvas {
                width: 100%;
                max-width: none;
                min-width: 300px;
            }
            .canvas-container {
                justify-content: center;
                gap: 4%;
            }
            .canvas-container > div {
                width: 48%;
            }
        }
        @media (min-width: 1001px) {
            .canvas-container > div {
                width: 450px;
            }
        }
        .control-group {
            width: 100%;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="file"] {
            margin-bottom: 10px;
        }
        .status {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        .slider-value {
            display: inline-block;
            width: 30px;
            text-align: right;
        }
        .processing-indicator {
            margin-left: 10px;
            color: #ff6600;
            display: none;
        }
        input[type="range"] {
            width: 75%;
            display: block;
        }
        @media (max-width: 700px) {
            input[type="range"] {
                width: 100%;
            }
        }
        .tonal-range {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            align-items: center;
            flex-direction: row;
        }
        @media (max-width: 700px) {
            .tonal-range {
                flex-direction: column;
                align-items: flex-start;
            }
        }
        .tonal-range label {
            display: inline-flex;
            align-items: center;
            margin: 0;
            cursor: pointer;
        }
        .tonal-values {
            font-size: 11px;
            color: #666;
            margin-left: 5px;
        }
        .active-range {
            font-weight: bold;
            color: #4CAF50;
        }
        .preset-container {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .preset-container select {
            flex-grow: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .preset-container button {
            padding: 6px 10px;
            margin: 0;
        }
        .color-picker-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .color-picker-container input[type="color"] {
            width: 40px;
            height: 30px;
            padding: 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .image-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }
        .image-actions button {
            padding: 6px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .image-actions button:hover {
            background-color: #45a049;
        }
        #imageOverlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    justify-content: center;
    align-items: center;
    overflow: auto;
}

#overlayCanvasContainer {
    display: flex;
    justify-content: center;
    align-items: center;
    aspect-ratio: 1 / 1;
    max-width: 90vmin;
    max-height: 90vmin;
}
        #overlayCanvas {
    max-width: 90%;
    max-height: 90%;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    aspect-ratio: 1 / 1;
    object-fit: contain;
}
        #closeOverlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        /* Webcam overlay styles */
        #webcamOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            justify-content: center;
            align-items: center;
        }
        #webcamContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        #webcamVideo {
            max-width: 90vmin;
            max-height: 70vh;
            border: 2px solid #4CAF50;
            border-radius: 8px;
        }
        #webcamControls {
            display: flex;
            gap: 15px;
        }
        #webcamControls button {
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }
        #captureBtn {
            background-color: #4CAF50;
            color: white;
        }
        #captureBtn:hover {
            background-color: #45a049;
        }
        #cancelWebcamBtn {
            background-color: #f44336;
            color: white;
        }
        #cancelWebcamBtn:hover {
            background-color: #da190b;
        }
        #closeWebcam {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 36px;
            cursor: pointer;
            z-index: 1002;
        }

        /* Hide overlay functionality for small screens */
        @media (max-width: 700px) {
            #viewLarger {
                display: none;
            }
        }
    </style>
</head>
<body>
    <h1>Struycken Algorithm Image Processor</h1>
    <div class="canvas-container">
        <div>
            <h4>Original Image</h4>
            <canvas id="originalCanvas"></canvas>
        </div>
        <div>
            <h4>Processed Image</h4>
            <canvas id="processedCanvas"></canvas>
            <div class="image-actions">
                <button id="viewLarger">View Larger</button>
                <button id="saveImage">Save Image</button>
            </div>
        </div>
    </div>
    
    <!-- Image overlay for larger view -->
    <div id="imageOverlay">
        <button id="closeOverlay">×</button>
        <div id="overlayCanvasContainer">
            <canvas id="overlayCanvas"></canvas>
        </div>
    </div>

    <div id="webcamOverlay">
        <button id="closeWebcam">×</button>
        <div id="webcamContainer">
            <video id="webcamVideo" autoplay playsinline></video>
            <div id="webcamControls">
                <button id="captureBtn">Capture Photo</button>
                <button id="cancelWebcamBtn">Cancel</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label for="gridSize">Grid Size: <span id="gridSizeValue" class="slider-value">128</span></label>
                <input type="range" id="gridSize" min="32" max="256" value="128" step="32">
            </div>
            <div class="control-group">
                <label for="iterations">Iterations: <span id="iterationsValue" class="slider-value">20</span></label>
                <input type="range" id="iterations" min="1" max="50" value="20">
            </div>
            <div class="control-group">
                <label for="dotSize">Dot Size: <span id="dotSizeValue" class="slider-value">1</span></label>
                <input type="range" id="dotSize" min="0.1" max="2" value="1" step="0.1">
            </div>
            <div class="control-group">
                <label for="territoryRadius">Territory Radius: <span id="territoryRadiusValue" class="slider-value">0.5</span></label>
                <input type="range" id="territoryRadius" min="0.1" max="1.5" value="0.5" step="0.05">
            </div>
            <div class="control-group" style="grid-column: 1 / -1;">
                <div class="tonal-range">
                    <label>
                        <input type="radio" name="tonal-range" value="shadows" checked>
                        Shadows
                        <span class="tonal-values" id="shadows-values">(B: 0, C: 1.00)</span>
                    </label>
                    <label>
                        <input type="radio" name="tonal-range" value="midtones">
                        Midtones
                        <span class="tonal-values" id="midtones-values">(B: 0, C: 1.00)</span>
                    </label>
                    <label>
                        <input type="radio" name="tonal-range" value="highlights">
                        Highlights
                        <span class="tonal-values" id="highlights-values">(B: 0, C: 1.00)</span>
                    </label>
                </div>
            </div>
            <div class="control-group">
                <label for="contrast">Contrast: <span id="contrastValue" class="slider-value">1.00</span></label>
                <input type="range" id="contrast" min="0.0" max="2" value="1" step="0.05">
            </div>
            <div class="control-group">
                <label for="brightness">Brightness: <span id="brightnessValue" class="slider-value">0</span></label>
                <input type="range" id="brightness" min="-100" max="100" value="0" step="1">
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="useLegacy">
                    Use Legacy
                </label>
            </div>
            <div class="control-group">
                <label for="dotColor">Dot Color</label>
                <div class="color-picker-container">
                    <input type="color" id="dotColor" value="#000000">
                    <span>Background will adjust automatically</span>
                </div>
            </div>
            <div class="control-group">
                <label for="imageUpload">Upload Image:</label>
                <input type="file" id="imageUpload" accept="image/*">
            </div>
            <div class="control-group">
                <button id="webcamBtn">Capture from Webcam</button>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="inverseImage">
                    Inverse Image
                </label>
            </div>
            <div class="control-group">
                <label for="bgGrayscale">Background Gray: <span id="bgGrayscaleValue" class="slider-value">255</span></label>
                <input type="range" id="bgGrayscale" min="0" max="255" value="255" step="1">
            </div>
            <div class="control-group">
                <button id="processBtn" disabled>Process Image</button>
                <button id="resetBtn">Reset</button>
                <span id="processingIndicator" class="processing-indicator">Processing...</span>
            </div>
            <div class="control-group">
                <div id="status" class="status">Upload an image to begin</div>
            </div>
            <div class="control-group" style="grid-column: 1 / -1;">
                <div class="preset-container">
                    <select id="presetSelect">
                        <option value="">-- Select Preset --</option>
                    </select>
                    <button id="savePresetBtn">Save Preset</button>
                </div>
            </div>
        </div>
        
    </div>

    <div class="container">
        <div class="controls" style="grid-column: 1 / -1;">
            <h4>Interaction Instructions</h4>
            <div style="margin-bottom: 15px;">
                <strong>Pan:</strong> Click and drag on the original image to pan and explore different areas.
            </div>
            <div style="margin-bottom: 15px;">
                <strong>Zoom:</strong> Hold down Cmd (Mac) or Ctrl (Windows) while using the scroll wheel over the original image.
            </div>
            <div style="margin-bottom: 15px;">
                <strong>Reset View:</strong> Uploading a new image or clicking Reset will restore the default view.
            </div>
            <div>
                <strong>Presets:</strong> Save your favorite settings with the preset system above. Presets include all slider values and colors.
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const imageUpload = document.getElementById('imageUpload');
        const gridSizeSlider = document.getElementById('gridSize');
        const gridSizeValue = document.getElementById('gridSizeValue');
        const iterationsSlider = document.getElementById('iterations');
        const iterationsValue = document.getElementById('iterationsValue');
        const dotSizeSlider = document.getElementById('dotSize');
        const dotSizeValue = document.getElementById('dotSizeValue');
        const contrastSlider = document.getElementById('contrast');
        const contrastValue = document.getElementById('contrastValue');
        const brightnessSlider = document.getElementById('brightness');
        const brightnessValue = document.getElementById('brightnessValue');
        const processBtn = document.getElementById('processBtn');
        const resetBtn = document.getElementById('resetBtn');
        const originalCanvas = document.getElementById('originalCanvas');
        const processedCanvas = document.getElementById('processedCanvas');
        const statusEl = document.getElementById('status');
        const processingIndicator = document.getElementById('processingIndicator');
        const presetSelect = document.getElementById('presetSelect');
        const savePresetBtn = document.getElementById('savePresetBtn');
        const dotColorInput = document.getElementById('dotColor');
        const territoryRadiusSlider = document.getElementById('territoryRadius');
        const territoryRadiusValue = document.getElementById('territoryRadiusValue');
        const inverseImageCheckbox = document.getElementById('inverseImage');
        const useLegacyCheckbox = document.getElementById('useLegacy');
        const bgGrayscaleSlider = document.getElementById('bgGrayscale');
        const bgGrayscaleValue = document.getElementById('bgGrayscaleValue');

        // Canvas contexts
        const originalCtx = originalCanvas.getContext('2d');
        const processedCtx = processedCanvas.getContext('2d');

        // Global variables
        let originalImage = null;
        let points = [];
        let imageData = null;
        let adjustments = {
            shadows: { brightness: 0, contrast: 1 },
            midtones: { brightness: 0, contrast: 1 },
            highlights: { brightness: 0, contrast: 1 }
        };
        let currentRange = 'shadows';
        let presets = {};
        let dotColor = '#000000';
        let bgColor = '#f0f0f0';
        let overlayActive = false;
        
        // Pan and zoom variables
        let isPanning = false;
        let isCtrlKeyDown = false;
        let zoomLevel = 1;
        let panX = 0;
        let panY = 0;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let originalImageWidth = 0;
        let originalImageHeight = 0;
        
        // Function to update canvas internal dimensions to match displayed size
        function updateCanvasDimensions() {
            // Get the computed style
            const originalRect = originalCanvas.getBoundingClientRect();
            const processedRect = processedCanvas.getBoundingClientRect();
            
            // Set the canvas internal dimensions to match displayed size
            originalCanvas.width = Math.round(originalRect.width);
            originalCanvas.height = Math.round(originalRect.height);
            processedCanvas.width = Math.round(processedRect.width);
            processedCanvas.height = Math.round(processedRect.height);
        }
        
        // Call once on page load
        updateCanvasDimensions();
        
        // Update canvas dimensions on window resize
        window.addEventListener('resize', () => {
            updateCanvasDimensions();
            if (originalImage) {
                drawOriginalImage();
            }
            if (points.length > 0) {
                drawProcessedImage(points, parseFloat(dotSizeSlider.value));
            }
        });

        // Pan and zoom event listeners
        originalCanvas.addEventListener('mousedown', (e) => {
            if (originalImage) {
                isPanning = true;
                lastMouseX = e.offsetX;
                lastMouseY = e.offsetY;
                originalCanvas.style.cursor = 'grabbing';
            }
        });
        
        originalCanvas.addEventListener('mousemove', (e) => {
            if (isPanning && originalImage) {
                const deltaX = e.offsetX - lastMouseX;
                const deltaY = e.offsetY - lastMouseY;
                
                panX += deltaX;
                panY += deltaY;
                
                lastMouseX = e.offsetX;
                lastMouseY = e.offsetY;
                
                drawOriginalImage();
            }
        });
        
        originalCanvas.addEventListener('mouseup', () => {
            isPanning = false;
            originalCanvas.style.cursor = 'default';
        });
        
        originalCanvas.addEventListener('mouseleave', () => {
            isPanning = false;
            originalCanvas.style.cursor = 'default';
        });
        
        originalCanvas.addEventListener('wheel', (e) => {
            if (originalImage && isCtrlKeyDown) {
                e.preventDefault();
                
                // Get mouse position relative to image
                const rect = originalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate where the mouse is on the image
                const viewportX = mouseX - panX;
                const viewportY = mouseY - panY;
                const imageSpaceX = viewportX / zoomLevel;
                const imageSpaceY = viewportY / zoomLevel;
                
                // Apply zoom
                const delta = e.deltaY > 0 ? 0.9 : 1.1; // Zoom in or out factor
                zoomLevel *= delta;
                
                // Limit zoom
                zoomLevel = Math.min(Math.max(0.1, zoomLevel), 10);
                
                // Adjust pan to keep the point under the mouse fixed
                panX = mouseX - imageSpaceX * zoomLevel;
                panY = mouseY - imageSpaceY * zoomLevel;
                
                drawOriginalImage();
            }
        });
        
        // Track ctrl/cmd key state
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                isCtrlKeyDown = true;
                originalCanvas.style.cursor = 'zoom-in';
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (!e.ctrlKey && !e.metaKey) {
                isCtrlKeyDown = false;
                originalCanvas.style.cursor = isPanning ? 'grabbing' : 'default';
            }
        });
        
        // Reset pan and zoom when loading a new image
        function resetPanZoom() {
            zoomLevel = 1;
            panX = 0;
            panY = 0;
        }

        // Update slider value displays
        gridSizeSlider.addEventListener('input', () => {
            gridSizeValue.textContent = gridSizeSlider.value;
        });
        
        iterationsSlider.addEventListener('input', () => {
            iterationsValue.textContent = iterationsSlider.value;
        });
        
        dotSizeSlider.addEventListener('input', () => {
            dotSizeValue.textContent = dotSizeSlider.value;
        });
        
        territoryRadiusSlider.addEventListener('input', () => {
            territoryRadiusValue.textContent = territoryRadiusSlider.value;
        });

        inverseImageCheckbox.addEventListener('change', () => {
            if (originalImage) {
                drawOriginalImage();
            }
        });

        useLegacyCheckbox.addEventListener('change', () => {
            if (originalImage) {
                drawOriginalImage();
            }
        });

        bgGrayscaleSlider.addEventListener('input', () => {
            bgGrayscaleValue.textContent = bgGrayscaleSlider.value;
            if (originalImage) {
                drawOriginalImage();
            }
        });

        // Add function to update tonal values display
        function updateTonalValues() {
            Object.keys(adjustments).forEach(range => {
                const values = adjustments[range];
                document.getElementById(`${range}-values`).textContent = 
                    `(B: ${values.brightness}, C: ${values.contrast.toFixed(2)})`;
            });
        }

        // Add radio button event listeners
        document.querySelectorAll('input[name="tonal-range"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                currentRange = e.target.value;
                // Update sliders to show current range's values
                brightnessSlider.value = adjustments[currentRange].brightness;
                contrastSlider.value = adjustments[currentRange].contrast;
                brightnessValue.textContent = adjustments[currentRange].brightness;
                contrastValue.textContent = adjustments[currentRange].contrast.toFixed(2);
                
                // Update active range styling
                document.querySelectorAll('.tonal-values').forEach(el => {
                    el.classList.remove('active-range');
                });
                document.getElementById(`${currentRange}-values`).classList.add('active-range');
            });
        });

        // Modify slider event listeners
        contrastSlider.addEventListener('input', () => {
            contrastValue.textContent = parseFloat(contrastSlider.value).toFixed(2);
            adjustments[currentRange].contrast = parseFloat(contrastSlider.value);
            updateTonalValues();
            if (originalImage) {
                drawOriginalImage();
            }
        });

        brightnessSlider.addEventListener('input', () => {
            brightnessValue.textContent = brightnessSlider.value;
            adjustments[currentRange].brightness = parseInt(brightnessSlider.value);
            updateTonalValues();
            if (originalImage) {
                drawOriginalImage();
            }
        });

        // Handle image upload
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                originalImage = new Image();
                originalImage.onload = () => {
                    resetPanZoom();
                    updateCanvasDimensions(); // Ensure canvas dimensions are up to date
                    drawOriginalImage();
                    processBtn.disabled = false;
                    statusEl.textContent = 'Image loaded. Click "Process Image" to apply the Struycken algorithm.';
                };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });

        // Draw the original image on canvas
        function drawOriginalImage() {
            // Clear the canvas
            originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            
            // Calculate proportions to fit the image within canvas
            const maxWidth = originalCanvas.width;
            const maxHeight = originalCanvas.height;
            let width = originalImage.width;
            let height = originalImage.height;
            
            if (width > height) {
                if (width > maxWidth) {
                    height = height * (maxWidth / width);
                    width = maxWidth;
                }
            } else {
                if (height > maxHeight) {
                    width = width * (maxHeight / height);
                    height = maxHeight;
                }
            }
            
            // Save original proportioned size
            originalImageWidth = width;
            originalImageHeight = height;
            
            // Apply zoom to dimensions
            width *= zoomLevel;
            height *= zoomLevel;
            
            // Center the image (with pan offset)
            const x = (maxWidth - originalImageWidth) / 2 + panX;
            const y = (maxHeight - originalImageHeight) / 2 + panY;
            
            // Create a temporary canvas for grayscale conversion and adjustments
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = originalImageWidth;
            tempCanvas.height = originalImageHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Fill background with the specified grayscale value (for transparency)
            const bgGray = parseInt(bgGrayscaleSlider.value);
            tempCtx.fillStyle = `rgb(${bgGray}, ${bgGray}, ${bgGray})`;
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

            // Draw the original image to temp canvas (transparent areas will show background)
            tempCtx.drawImage(originalImage, 0, 0, originalImageWidth, originalImageHeight);
            
            // Get image data for processing
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            
            // Process each pixel
            for (let i = 0; i < data.length; i += 4) {
                // Convert to grayscale
                const gray = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                
                // Determine which adjustment to use based on luminance
                let adjusted;
                if (gray <= 85) { // Shadows
                    adjusted = applyAdjustments(gray, adjustments.shadows);
                } else if (gray <= 170) { // Midtones
                    const shadowWeight = (170 - gray) / 85;
                    const highlightWeight = (gray - 85) / 85;
                    const shadowAdjusted = applyAdjustments(gray, adjustments.shadows);
                    const midAdjusted = applyAdjustments(gray, adjustments.midtones);
                    adjusted = shadowAdjusted * shadowWeight + midAdjusted * highlightWeight;
                } else { // Highlights
                    const midWeight = (255 - gray) / 85;
                    const highlightWeight = (gray - 170) / 85;
                    const midAdjusted = applyAdjustments(gray, adjustments.midtones);
                    const highlightAdjusted = applyAdjustments(gray, adjustments.highlights);
                    adjusted = midAdjusted * midWeight + highlightAdjusted * highlightWeight;
                }
                
                // Clamp values
                let final = Math.max(0, Math.min(255, adjusted));

                // Apply inversion if checkbox is checked
                if (inverseImageCheckbox.checked) {
                    final = 255 - final;
                }

                data[i] = final;     // R
                data[i + 1] = final; // G
                data[i + 2] = final; // B
            }
            
            // Put the processed image data back
            tempCtx.putImageData(imageData, 0, 0);
            
            // Draw the processed image to the original canvas
            originalCtx.drawImage(tempCanvas, x, y, width, height);
        }

        function applyAdjustments(value, adjustments) {
            if (useLegacyCheckbox.checked) {
                // Legacy method: Simple linear adjustments (pre-CS3)
                // This method can clip highlights and shadows
                let adjusted = value + adjustments.brightness;
                adjusted = (adjusted - 128) * adjustments.contrast + 128;
                return adjusted;
            } else {
                // Modern method: Non-linear adjustments that preserve detail (CS3+)
                // Normalize to 0-1 range for calculations
                let normalized = value / 255;

                // Apply brightness using a non-linear curve that tapers at extremes
                // This preserves highlight and shadow detail
                const brightnessAmount = adjustments.brightness / 255;
                if (brightnessAmount > 0) {
                    // Brighten: less effect on already bright values
                    normalized = normalized + brightnessAmount * (1 - normalized);
                } else {
                    // Darken: less effect on already dark values
                    normalized = normalized + brightnessAmount * normalized;
                }

                // Apply contrast using an S-curve that protects extremes
                // Map contrast slider (0-2) to a more usable range
                const contrastFactor = adjustments.contrast;
                if (contrastFactor !== 1.0) {
                    // Center around 0.5 (mid-gray)
                    normalized = (normalized - 0.5) * contrastFactor + 0.5;

                    // Apply subtle S-curve to smooth the transition
                    // This prevents harsh clipping at extremes
                    if (normalized > 0.5) {
                        const t = (normalized - 0.5) * 2; // 0-1 range for upper half
                        const eased = t * t * (3 - 2 * t); // Smoothstep function
                        normalized = 0.5 + eased * 0.5;
                    } else {
                        const t = normalized * 2; // 0-1 range for lower half
                        const eased = t * t * (3 - 2 * t); // Smoothstep function
                        normalized = eased * 0.5;
                    }
                }

                // Convert back to 0-255 range
                return normalized * 255;
            }
        }

        // Process button click handler
        processBtn.addEventListener('click', async () => {
            if (!originalImage) return;
            
            processingIndicator.style.display = 'inline';
            processBtn.disabled = true;
            statusEl.textContent = 'Processing...';
            
            // Allow UI to update before starting processing
            await new Promise(resolve => setTimeout(resolve, 50));
            
            const gridSize = parseInt(gridSizeSlider.value);
            const iterations = parseInt(iterationsSlider.value);
            const dotSize = parseFloat(dotSizeSlider.value);
            
            processImage(gridSize, iterations, dotSize);
        });

        // Reset button click handler
        resetBtn.addEventListener('click', () => {
            // Reset all control values to defaults
            gridSizeSlider.value = 128;
            gridSizeValue.textContent = '128';

            iterationsSlider.value = 20;
            iterationsValue.textContent = '20';

            dotSizeSlider.value = 1;
            dotSizeValue.textContent = '1';

            territoryRadiusSlider.value = 0.5;
            territoryRadiusValue.textContent = '0.5';

            dotColorInput.value = '#000000';
            dotColor = '#000000';
            bgColor = '#f0f0f0';

            inverseImageCheckbox.checked = false;
            useLegacyCheckbox.checked = false;

            bgGrayscaleSlider.value = 255;
            bgGrayscaleValue.textContent = '255';

            // Reset all tonal adjustments
            adjustments = {
                shadows: { brightness: 0, contrast: 1 },
                midtones: { brightness: 0, contrast: 1 },
                highlights: { brightness: 0, contrast: 1 }
            };

            // Reset to shadows range
            currentRange = 'shadows';
            document.querySelector('input[name="tonal-range"][value="shadows"]').checked = true;

            // Reset brightness and contrast sliders
            brightnessSlider.value = 0;
            brightnessValue.textContent = '0';
            contrastSlider.value = 1;
            contrastValue.textContent = '1.00';

            // Update tonal values display
            updateTonalValues();

            // Update active range styling
            document.querySelectorAll('.tonal-values').forEach(el => {
                el.classList.remove('active-range');
            });
            document.getElementById('shadows-values').classList.add('active-range');

            // Clear processed canvas
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            points = [];

            // Redraw original image with reset controls if image is loaded
            if (originalImage) {
                drawOriginalImage();
                statusEl.textContent = 'Controls reset. Click Process Image to apply Struycken algorithm.';
            } else {
                statusEl.textContent = 'Upload an image to begin';
            }
        });

        // Main image processing function
        function processImage(gridSize, iterations, dotSize) {
            // Step 1: Prepare a grayscale version of the image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = gridSize;
            tempCanvas.height = gridSize;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Draw and resize the image to fit the grid
            const size = Math.min(originalCanvas.width, originalCanvas.height);
            tempCtx.drawImage(
                originalCanvas, 
                (originalCanvas.width - size) / 2, 
                (originalCanvas.height - size) / 2, 
                size, size, 
                0, 0, gridSize, gridSize
            );
            
            // Get image data
            imageData = tempCtx.getImageData(0, 0, gridSize, gridSize);
            
            // Step 2: Apply the Struycken algorithm
            points = determinePointPlacement(imageData, gridSize);
            
            // Step 3: Randomize point positions
            for (let i = 0; i < iterations; i++) {
                randomizePointPositions(points, gridSize);
                
                // Update status for long operations
                if (i % 5 === 0 || i === iterations - 1) {
                    statusEl.textContent = `Processing... Iteration ${i + 1}/${iterations}`;
                }
            }
            
            // Step 4: Draw the result
            drawProcessedImage(points, dotSize);
            
            processingIndicator.style.display = 'none';
            processBtn.disabled = false;
            statusEl.textContent = 'Processing complete!';
        }

        // Determine initial point placement (first phase of the algorithm)
        function determinePointPlacement(imageData, gridSize) {
            const points = [];
            const data = imageData.data;
            let sum = 0;
            
            // Scan the image in a meandering pattern
            for (let y = 0; y < gridSize; y++) {
                // Determine scan direction (left-to-right or right-to-left)
                const leftToRight = y % 2 === 0;
                
                for (let x = 0; x < gridSize; x++) {
                    // Adjust x-coordinate for the current scan direction
                    const xPos = leftToRight ? x : gridSize - 1 - x;
                    
                    // Calculate the pixel index
                    const idx = (y * gridSize + xPos) * 4;
                    
                    // Calculate grayscale value (perceptual luminance)
                    const gray = data[idx] * 0.299 + data[idx + 1] * 0.587 + data[idx + 2] * 0.114;
                    
                    // Invert grayscale (0=white, 255=black)
                    const invertedGray = 255 - gray;
                    
                    // Add to sum
                    sum += invertedGray;
                    
                    // If sum exceeds 255, place a point
                    if (sum >= 255) {
                        points.push({
                            x: xPos,
                            y: y,
                            originX: xPos,  // Track original position
                            originY: y      // Track original position
                        });
                        sum -= 255;
                    }
                }
            }
            
            return points;
        }

        // Randomize point positions (second phase of the algorithm)
        function randomizePointPositions(points, gridSize) {
            const territoryRadius = parseFloat(territoryRadiusSlider.value); // Use value from slider
            
            // Create a spatial hash grid to speed up nearby point checks
            const cellSize = territoryRadius * 2;
            const gridCells = Math.ceil(gridSize / cellSize);
            const spatialGrid = Array(gridCells).fill().map(() => Array(gridCells).fill().map(() => []));
            
            // Add all points to the spatial grid
            points.forEach((point, index) => {
                const cellX = Math.floor(point.x / cellSize);
                const cellY = Math.floor(point.y / cellSize);
                if (cellX >= 0 && cellX < gridCells && cellY >= 0 && cellY < gridCells) {
                    spatialGrid[cellY][cellX].push(index);
                }
            });
            
            // Process each point with a random order
            const indices = Array.from({ length: points.length }, (_, i) => i);
            shuffleArray(indices);
            
            for (const i of indices) {
                const point = points[i];

                // Check if point has already reached its maximum displacement (3 units from origin)
                const currentDisplacementX = Math.abs(point.x - point.originX);
                const currentDisplacementY = Math.abs(point.y - point.originY);

                // Skip points that are already at the boundary in both directions
                if (currentDisplacementX >= 3 && currentDisplacementY >= 3) {
                    continue;
                }

                // Try multiple random moves for each point (increasing chances of finding valid move)
                let foundValidMove = false;
                for (let attempts = 0; attempts < 5 && !foundValidMove; attempts++) {
                    // Choose one of 4 cardinal directions: up, down, left, right
                    // This matches the Dutch algorithm description:
                    // "naar onderen of naar boven, of naar links en rechts"
                    const subgridOffset = 0.4;
                    const directions = [
                        { dx: 0, dy: -subgridOffset },  // up
                        { dx: 0, dy: subgridOffset },   // down
                        { dx: -subgridOffset, dy: 0 },  // left
                        { dx: subgridOffset, dy: 0 }    // right
                    ];
                    const direction = directions[Math.floor(Math.random() * 4)];

                    // Calculate new position with sub-grid movement (0.25 grid cell steps)
                    const newX = point.x + direction.dx;
                    const newY = point.y + direction.dy;

                    // Check if new position is within grid bounds
                    if (newX < 0 || newX >= gridSize || newY < 0 || newY >= gridSize) {
                        continue; // Skip if out of bounds
                    }

                    // Check if new position would exceed the 3-unit boundary from origin
                    const newDisplacementX = Math.abs(newX - point.originX);
                    const newDisplacementY = Math.abs(newY - point.originY);

                    if (newDisplacementX > (3 * subgridOffset) || newDisplacementY > (3 * subgridOffset)) {
                        continue; // Skip if would exceed 3-unit boundary
                    }
                    
                    // Check if new position overlaps with nearby points' territories
                    let canMove = true;
                    
                    // Only check nearby cells in the spatial grid
                    const cellX = Math.floor(newX / cellSize);
                    const cellY = Math.floor(newY / cellSize);
                    
                    for (let ny = Math.max(0, cellY - 1); ny <= Math.min(gridCells - 1, cellY + 1); ny++) {
                        for (let nx = Math.max(0, cellX - 1); nx <= Math.min(gridCells - 1, cellX + 1); nx++) {
                            for (const j of spatialGrid[ny][nx]) {
                                if (i === j) continue; // Skip self
                                
                                const otherPoint = points[j];
                                const distance = Math.sqrt(
                                    Math.pow(newX - otherPoint.x, 2) + 
                                    Math.pow(newY - otherPoint.y, 2)
                                );
                                
                                if (distance < territoryRadius * 2) {
                                    canMove = false;
                                    break;
                                }
                            }
                            if (!canMove) break;
                        }
                        if (!canMove) break;
                    }
                    
                    // Update position if allowed
                    if (canMove) {
                        // Update spatial grid
                        const oldCellX = Math.floor(point.x / cellSize);
                        const oldCellY = Math.floor(point.y / cellSize);
                        
                        if (oldCellX >= 0 && oldCellX < gridCells && oldCellY >= 0 && oldCellY < gridCells) {
                            const cellPoints = spatialGrid[oldCellY][oldCellX];
                            spatialGrid[oldCellY][oldCellX] = cellPoints.filter(idx => idx !== i);
                        }
                        
                        // Update point position
                        point.x = newX;
                        point.y = newY;
                        
                        // Add to new cell
                        if (cellX >= 0 && cellX < gridCells && cellY >= 0 && cellY < gridCells) {
                            spatialGrid[cellY][cellX].push(i);
                        }
                        
                        foundValidMove = true;
                    }
                }
            }
        }
        
        // Helper function to shuffle array in-place (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Draw the processed image with points
        function drawProcessedImage(points, dotSize) {
            // Clear canvas
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.fillStyle = bgColor;
            processedCtx.fillRect(0, 0, processedCanvas.width, processedCanvas.height);
            
            // Calculate scaling factor
            const gridSize = parseInt(gridSizeSlider.value);
            const scale = processedCanvas.width / gridSize;
            
            // Draw points
            processedCtx.fillStyle = dotColor;
            
            points.forEach(point => {
                processedCtx.beginPath();
                processedCtx.arc(
                    point.x * scale, 
                    point.y * scale, 
                    dotSize, 
                    0, 
                    Math.PI * 2
                );
                processedCtx.fill();
            });
        }

        // Load presets from localStorage
        function loadPresets() {
            const savedPresets = localStorage.getItem('structykenPresets');
            if (savedPresets) {
                presets = JSON.parse(savedPresets);
                updatePresetOptions();
            }
        }
        
        // Update preset select options
        function updatePresetOptions() {
            // Clear existing options except the default
            while (presetSelect.options.length > 1) {
                presetSelect.remove(1);
            }
            
            // Add options for each preset
            Object.keys(presets).forEach(name => {
                const option = new Option(name, name);
                presetSelect.add(option);
            });
        }
        
        // Get current settings as a preset object
        function getCurrentSettings() {
            return {
                adjustments: JSON.parse(JSON.stringify(adjustments)),
                gridSize: parseInt(gridSizeSlider.value),
                iterations: parseInt(iterationsSlider.value),
                dotSize: parseFloat(dotSizeSlider.value),
                territoryRadius: parseFloat(territoryRadiusSlider.value),
                dotColor: dotColorInput.value
            };
        }
        
        // Apply settings from a preset
        function applyPreset(preset) {
            // Apply adjustments
            adjustments = JSON.parse(JSON.stringify(preset.adjustments));
            
            // Update sliders
            gridSizeSlider.value = preset.gridSize;
            gridSizeValue.textContent = preset.gridSize;
            
            iterationsSlider.value = preset.iterations;
            iterationsValue.textContent = preset.iterations;
            
            dotSizeSlider.value = preset.dotSize;
            dotSizeValue.textContent = preset.dotSize;
            
            // Update territory radius if present
            if (preset.territoryRadius) {
                territoryRadiusSlider.value = preset.territoryRadius;
                territoryRadiusValue.textContent = preset.territoryRadius;
            }
            
            // Update color if present in the preset
            if (preset.dotColor) {
                dotColorInput.value = preset.dotColor;
                updateColors();
            }
            
            // Set contrast and brightness for current tonal range
            brightnessSlider.value = adjustments[currentRange].brightness;
            brightnessValue.textContent = adjustments[currentRange].brightness;
            
            contrastSlider.value = adjustments[currentRange].contrast;
            contrastValue.textContent = adjustments[currentRange].contrast.toFixed(2);
            
            // Update tonal range displays
            updateTonalValues();
            
            // Update image if one is loaded
            if (originalImage) {
                drawOriginalImage();
            }
        }
        
        // Save current settings as a preset
        function savePreset(name) {
            presets[name] = getCurrentSettings();
            localStorage.setItem('structykenPresets', JSON.stringify(presets));
            updatePresetOptions();
            presetSelect.value = name;
        }
        
        // Remove a preset
        function removePreset(name) {
            delete presets[name];
            localStorage.setItem('structykenPresets', JSON.stringify(presets));
            updatePresetOptions();
            presetSelect.selectedIndex = 0;
        }
        
        // Event handlers for preset interface
        savePresetBtn.addEventListener('click', () => {
            const selectedPreset = presetSelect.value;
            
            if (savePresetBtn.textContent === 'Save Preset') {
                // Save mode
                const name = prompt('Enter a name for this preset:', selectedPreset !== '' ? selectedPreset : '');
                if (name && name.trim() !== '') {
                    savePreset(name.trim());
                    statusEl.textContent = `Preset "${name}" saved.`;
                }
            } else {
                // Remove mode
                if (selectedPreset && confirm(`Are you sure you want to remove preset "${selectedPreset}"?`)) {
                    removePreset(selectedPreset);
                    savePresetBtn.textContent = 'Save Preset';
                    statusEl.textContent = `Preset "${selectedPreset}" removed.`;
                }
            }
        });
        
        presetSelect.addEventListener('change', () => {
            const selectedPreset = presetSelect.value;
            
            if (selectedPreset === '') {
                savePresetBtn.textContent = 'Save Preset';
            } else {
                savePresetBtn.textContent = 'Remove Preset';
                applyPreset(presets[selectedPreset]);
                statusEl.textContent = `Preset "${selectedPreset}" loaded.`;
            }
        });
        
        // Load presets on page load
        loadPresets();

        // Convert hex color to RGB
        function hexToRgb(hex) {
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Convert to RGB values
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            return { r, g, b };
        }
        
        // Calculate light background color from dot color
        function calculateLightBgColor(hexColor) {
            const rgb = hexToRgb(hexColor);
            
            // Mix with white at 95% white, 5% original color
            const r = Math.round(rgb.r * 0.05 + 255 * 0.95);
            const g = Math.round(rgb.g * 0.05 + 255 * 0.95);
            const b = Math.round(rgb.b * 0.05 + 255 * 0.95);
            
            // Ensure values are at least 240
            const finalR = Math.max(240, r);
            const finalG = Math.max(240, g);
            const finalB = Math.max(240, b);
            
            return `rgb(${finalR}, ${finalG}, ${finalB})`;
        }
        
        // Update colors when dot color changes
        function updateColors() {
            dotColor = dotColorInput.value;
            bgColor = calculateLightBgColor(dotColor);
            
            // Redraw if there are points
            if (points.length > 0) {
                drawProcessedImage(points, parseFloat(dotSizeSlider.value));
            }
        }
        
        // Listen for color changes
        dotColorInput.addEventListener('input', updateColors);

        // Function to show processed image in overlay
        function showImageOverlay() {
            if (window.innerWidth <= 700) return; // Don't show overlay on small screens
            
            const overlay = document.getElementById('imageOverlay');
            const overlayCanvas = document.getElementById('overlayCanvas');
            const overlayCtx = overlayCanvas.getContext('2d');
            
                // Set overlay canvas size - make it larger than the original but ensure it's square
    const maxSize = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9);
    overlayCanvas.width = maxSize;
    overlayCanvas.height = maxSize;
    
    // Force square aspect ratio in the DOM
    overlayCanvas.style.width = maxSize + 'px';
    overlayCanvas.style.height = maxSize + 'px';
            
            // Draw the processed image to the overlay canvas
            overlayCtx.fillStyle = bgColor;
            overlayCtx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            // Calculate scaling factor for the overlay
            const gridSize = parseInt(gridSizeSlider.value);
            const scale = maxSize / gridSize;
            const currentDotSize = parseFloat(dotSizeSlider.value);
            
            // Draw points
            overlayCtx.fillStyle = dotColor;
            
            // Only proceed if we have points
            if (points && points.length > 0) {
                // Calculate dot size ratio between original and enlarged canvas
                const sizeRatio = maxSize / processedCanvas.width;
                const enlargedDotSize = currentDotSize * sizeRatio;
                
                points.forEach(point => {
                    overlayCtx.beginPath();
                    overlayCtx.arc(
                        point.x * scale, 
                        point.y * scale, 
                        enlargedDotSize, 
                        0, 
                        Math.PI * 2
                    );
                    overlayCtx.fill();
                });
                
                // Show overlay
                overlay.style.display = 'flex';
                overlayActive = true;
            } else {
                // If there are no points, show an error message
                statusEl.textContent = "No processed image data available. Process an image first.";
            }
        }
        
        // Function to save the processed image at high resolution
        function saveProcessedImage() {
            if (!points || points.length === 0) {
                statusEl.textContent = "No processed image data available. Process an image first.";
                return;
            }

            // Create a high-resolution temporary canvas for export
            const exportCanvas = document.createElement('canvas');
            const exportSize = 4096; // High resolution for detailed output
            exportCanvas.width = exportSize;
            exportCanvas.height = exportSize;
            const exportCtx = exportCanvas.getContext('2d');

            // Fill background
            exportCtx.fillStyle = bgColor;
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

            // Calculate scaling factor for high-res export
            const gridSize = parseInt(gridSizeSlider.value);
            const scale = exportSize / gridSize;
            const currentDotSize = parseFloat(dotSizeSlider.value);

            // Calculate dot size for high-res export
            const sizeRatio = exportSize / processedCanvas.width;
            const exportDotSize = currentDotSize * sizeRatio;

            // Draw points at high resolution
            exportCtx.fillStyle = dotColor;
            points.forEach(point => {
                exportCtx.beginPath();
                exportCtx.arc(
                    point.x * scale,
                    point.y * scale,
                    exportDotSize,
                    0,
                    Math.PI * 2
                );
                exportCtx.fill();
            });

            // Create a temporary link element
            const link = document.createElement('a');

            // Set the download attribute with a filename
            link.download = 'struycken-processed-4096.png';

            // Convert the high-res canvas to a data URL
            link.href = exportCanvas.toDataURL('image/png');

            // Append to the document, trigger click, and remove
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            // Update status
            statusEl.textContent = 'High-resolution image (4096x4096) saved successfully!';
        }
        
        // Event listeners for new features
        document.getElementById('viewLarger').addEventListener('click', showImageOverlay);
        document.getElementById('saveImage').addEventListener('click', saveProcessedImage);
        
        // Close overlay when close button is clicked
        document.getElementById('closeOverlay').addEventListener('click', () => {
            document.getElementById('imageOverlay').style.display = 'none';
            overlayActive = false;
        });
        
        // Close overlay when clicking outside the image
        document.getElementById('imageOverlay').addEventListener('click', (e) => {
            if (e.target === document.getElementById('imageOverlay')) {
                document.getElementById('imageOverlay').style.display = 'none';
                overlayActive = false;
            }
        });
        
        // Handle ESC key to close overlay
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && overlayActive) {
                document.getElementById('imageOverlay').style.display = 'none';
                overlayActive = false;
            }
        });

        // Webcam functionality
        let webcamStream = null;
        const webcamBtn = document.getElementById('webcamBtn');
        const webcamOverlay = document.getElementById('webcamOverlay');
        const webcamVideo = document.getElementById('webcamVideo');
        const captureBtn = document.getElementById('captureBtn');
        const cancelWebcamBtn = document.getElementById('cancelWebcamBtn');
        const closeWebcamBtn = document.getElementById('closeWebcam');

        // Function to start webcam
        async function startWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                webcamVideo.srcObject = webcamStream;
                webcamOverlay.style.display = 'flex';
                statusEl.textContent = 'Webcam active. Position yourself and click Capture Photo.';
            } catch (error) {
                console.error('Error accessing webcam:', error);
                statusEl.textContent = 'Error: Could not access webcam. Please check permissions.';
            }
        }

        // Function to stop webcam
        function stopWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
                webcamVideo.srcObject = null;
            }
            webcamOverlay.style.display = 'none';
        }

        // Function to capture photo from webcam
        function capturePhoto() {
            // Create a temporary canvas to capture the frame
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = webcamVideo.videoWidth;
            captureCanvas.height = webcamVideo.videoHeight;
            const captureCtx = captureCanvas.getContext('2d');

            // Draw the current video frame
            captureCtx.drawImage(webcamVideo, 0, 0);

            // Convert to image
            captureCanvas.toBlob((blob) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    drawOriginalImage();
                    processBtn.disabled = false;
                    statusEl.textContent = 'Photo captured! Adjust controls and click Process Image.';

                    // Reset processed canvas and points
                    processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
                    points = [];
                };
                img.src = URL.createObjectURL(blob);
            });

            // Stop and close webcam
            stopWebcam();
        }

        // Event listeners for webcam
        webcamBtn.addEventListener('click', startWebcam);
        captureBtn.addEventListener('click', capturePhoto);
        cancelWebcamBtn.addEventListener('click', stopWebcam);
        closeWebcamBtn.addEventListener('click', stopWebcam);

        // Close webcam on ESC key
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && webcamStream) {
                stopWebcam();
            }
        });
    </script>
</body>
</html>